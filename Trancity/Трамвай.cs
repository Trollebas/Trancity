using Common;
using Engine;
using SlimDX;
using System;
using System.Collections.Generic;
using System.IO;
using System.Windows.Forms;

namespace Trancity
{
    /// <summary>
    /// new
    /// </summary>
    public abstract class Трамвай : Рельсовый_Транспорт//Transport
    {
        //        public Трамвай[] вагоны = new Трамвай[0];
        //        private Трамвай _первыйВагон;
        public Токоприёмник_new токоприёмник;
        public Тележка[] тележки;

        public override void АвтоматическиУправлять(World мир)
        {
            var ost_dist = 2000.0;
            var stops_dist = 2000.0;
            var some_other_fucking_distance = 2000.0;
            var signals_dist = 2000.0;
            Рельс next_rail = null;
            base.stand_brake = false;
            if (передняя_ось.текущий_рельс.следующие_рельсы.Length > 0)
                next_rail = передняя_ось.текущий_рельс.следующие_рельсы[передняя_ось.текущий_рельс.следующий_рельс];
            else
                signals_dist = передняя_ось.текущий_рельс.Длина - передняя_ось.пройденное_расстояние_по_рельсу;
            base.UpdateTripStops();
            ost_dist = передняя_ось.текущий_рельс.Длина - передняя_ось.пройденное_расстояние_по_рельсу;
            if (((передняя_ось.текущий_рельс.следующие_рельсы.Length == 1) && !передняя_ось.текущий_рельс.кривая) && !next_rail.кривая)
            {
                ost_dist += next_rail.Длина;
            }
            foreach (var obj2 in передняя_ось.текущий_рельс.objects)
            {
                if (obj2 is Stop)
                {
                    var остановка = (Stop)obj2;
                    if ((((остановка.distance - передняя_ось.пройденное_расстояние_по_рельсу) <= 10.0) || //10.0
                        ((рейс != null) && !остановка.ПутьПодходит(рейс.pathes))) ||
                        ((маршрут == null) || (!остановка.typeOfTransport[маршрут.typeOfTransport])) || ((currentStop != null) && (остановка != currentStop))) continue;// || (остановка!=nextStop)) continue;
                    base.SearchForCurrentStop(остановка);
                    if (остановка != nextStop) continue;
                    stops_dist = Math.Min(stops_dist, остановка.distance - передняя_ось.пройденное_расстояние_по_рельсу);
                    базоваяОстановка = остановка;
                    currentStop = остановка;
                }
                if (obj2 is Visual_Signal/*Сигнальная_система.Сигнал*/)
                {
                    var сигнал = (Visual_Signal/*Сигнальная_система.Сигнал*/)obj2;
                    if ((сигнал.система.сигнал == Сигналы.Красный) && ((сигнал.положение.расстояние - передняя_ось.пройденное_расстояние_по_рельсу) > 10.0))
                    {
                        signals_dist = Math.Min(signals_dist, (сигнал.положение.расстояние - передняя_ось.пройденное_расстояние_по_рельсу) - 30.0);
                    }
                }
                if (obj2 is Светофорный_сигнал)
                {
                    var сигнал2 = (Светофорный_сигнал)obj2;
                    var num5 = сигнал2.расстояние - передняя_ось.пройденное_расстояние_по_рельсу;
                    if (((сигнал2.сигнал == Сигналы.Красный) && (num5 > 5.0)) || ((сигнал2.сигнал == Сигналы.Жёлтый) && (num5 > 15.0)))
                    {
                        signals_dist = Math.Min(signals_dist, num5 - 10.0);
                    }
                }
                //пропускаем других на стрелке, часть 1:
                if ((передняя_ось.текущий_рельс.следующие_рельсы.Length <= 1) || (!(obj2 is Ось))) continue;
                var axis = (Ось)obj2;
                if ((axis.задняя) && (axis.трамвай != this) && (axis.пройденное_расстояние_по_рельсу > axis.текущий_рельс.Длина - axis.текущий_рельс.расстояние_добавочных_проводов))//зачем нам другие оси?
                {
                    some_other_fucking_distance = Math.Min(some_other_fucking_distance, (передняя_ось.текущий_рельс.Длина - передняя_ось.пройденное_расстояние_по_рельсу) - (передняя_ось.текущий_рельс.расстояние_добавочных_проводов));
                }
            }
            if (next_rail != null)
            {
                foreach (var obj3 in next_rail.objects)
                {
                    if (obj3 is Stop)
                    {
                        var остановка2 = (Stop)obj3;
                        if (((рейс == null) || остановка2.ПутьПодходит(рейс.pathes)) && ((маршрут != null) && (остановка2.typeOfTransport[маршрут.typeOfTransport]) && (остановка2 == nextStop)))
                        {
                            stops_dist = Math.Min(stops_dist,
                                            (передняя_ось.текущий_рельс.Длина -
                                             передняя_ось.пройденное_расстояние_по_рельсу) + остановка2.distance);
                        }
                    }
                    if (obj3 is Visual_Signal/*Сигнальная_система.Сигнал*/)
                    {
                        var сигнал2 = (Visual_Signal/*Сигнальная_система.Сигнал*/)obj3;
                        if (сигнал2.система.сигнал == Сигналы.Красный)
                        {
                            signals_dist = Math.Min(signals_dist, ((передняя_ось.текущий_рельс.Длина - передняя_ось.пройденное_расстояние_по_рельсу) + сигнал2.положение.расстояние) - 30.0);
                        }
                    }
                    if (obj3 is Светофорный_сигнал)
                    {
                        var сигнал21 = (Светофорный_сигнал)obj3;
                        var num6 = (передняя_ось.текущий_рельс.Длина - передняя_ось.пройденное_расстояние_по_рельсу) + сигнал21.расстояние;
                        if (((сигнал21.сигнал == Сигналы.Красный) && (num6 > 5.0)) || ((сигнал21.сигнал == Сигналы.Жёлтый) && (num6 > 15.0)))
                        {
                            signals_dist = Math.Min(signals_dist, num6 - 10.0);
                        }
                    }
                    //пропускаем других на стрелке, часть 2:
                    if (передняя_ось.текущий_рельс.следующие_рельсы.Length <= 1) continue;
                    if (obj3 is Ось)
                    {
                        var ось = (Ось)obj3;
                        if (!(ось.передняя) || (ось.трамвай == this)) continue;//<- всё норм
                        if (ось.трамвай.задняя_ось.текущий_рельс != ось.текущий_рельс)
                        {
                            some_other_fucking_distance = Math.Min(some_other_fucking_distance, передняя_ось.текущий_рельс.Длина - передняя_ось.пройденное_расстояние_по_рельсу - (передняя_ось.текущий_рельс.расстояние_добавочных_проводов));
                        }
                    }
                }
                if (next_rail.предыдущие_рельсы.Length > 1)
                {
                    int j = -1;
                    for (int i = 0; i < next_rail.предыдущие_рельсы.Length; i++)
                    {
                        /*if (передняя_ось.текущий_рельс != рельс.предыдущие_рельсы[i])
                        {
                            ind = i;
                            break;
                        }*/
                        //обеспечил универсальность:
                        if (передняя_ось.текущий_рельс == next_rail.предыдущие_рельсы[i])
                        {
                            j = i;
                            continue;
                        }
                        foreach (var obj4 in next_rail.предыдущие_рельсы[i].objects)
                        {
                            if (!(obj4 is Ось)) continue;
                            var ось = (Ось)obj4;
                            //                        if ((!ось.передняя) && (!ось.задняя)) continue;
                            //пропускаем других на стрелке, часть 3:
                            if (((ось.пройденное_расстояние_по_рельсу > (ось.текущий_рельс.Длина - ось.текущий_рельс.расстояние_добавочных_проводов - 10.0)) &&
                                 (j < 0/*ось.трамвай.скорость > this.скорость*/)) || (ось.задняя && ось.текущий_рельс != ось.трамвай.передняя_ось.текущий_рельс))// && (передняя_ось.пройденное_расстояние_по_рельсу < передняя_ось.текущий_рельс.расстояние_добавочных_проводов))
                            {
                                some_other_fucking_distance = Math.Min(some_other_fucking_distance, передняя_ось.текущий_рельс.Длина - передняя_ось.пройденное_расстояние_по_рельсу - (передняя_ось.текущий_рельс.расстояние_добавочных_проводов));
                            }
                        }
                    }
                }
                List<Положение> list2 = new List<Положение>(next_rail.занятыеПоложения);
                foreach (var положение2 in list2)
                {
                    if (положение2.comment == this) continue;
                    some_other_fucking_distance = Math.Min(some_other_fucking_distance, (текущее_положение.Дорога.Длина - текущее_положение.расстояние) + положение2.расстояние - 2.0);
                }
            }
            /*if ((рельс != null) && (рельс.предыдущие_рельсы.Length > 1))// && (передняя_ось.текущий_рельс.следующие_рельсы.Length > 1))
            {
//                var ind = -10;
                for (int i = 0; i < рельс.предыдущие_рельсы.Length; i++)
                {
                    /*if (передняя_ось.текущий_рельс != рельс.предыдущие_рельсы[i])
                    {
                        ind = i;
                        break;
                    }*
                    //обеспечил универсальность:
                    if (передняя_ось.текущий_рельс == рельс.предыдущие_рельсы[i]) continue;
                    foreach (var obj4 in рельс.предыдущие_рельсы[i].objects)
                    {
                        if (!(obj4 is Ось)) continue;
                        var ось = (Ось)obj4;
//                        if ((!ось.передняя) && (!ось.задняя)) continue;
                        //пропускаем других на стрелке, часть 3:
                        if (((ось.пройденное_расстояние_по_рельсу > (ось.текущий_рельс.Длина - ось.текущий_рельс.расстояние_добавочных_проводов - 10.0)) &&
                             (ось.трамвай.скорость > this.скорость)) || (ось.задняя && ось.текущий_рельс != ось.трамвай.передняя_ось.текущий_рельс))// && (передняя_ось.пройденное_расстояние_по_рельсу < передняя_ось.текущий_рельс.расстояние_добавочных_проводов))
                        {
                            some_other_fucking_distance = Math.Min(some_other_fucking_distance, передняя_ось.текущий_рельс.Длина - передняя_ось.пройденное_расстояние_по_рельсу - (передняя_ось.текущий_рельс.расстояние_добавочных_проводов));
                        }
                    }
                }
                /*foreach (var obj4 in рельс.предыдущие_рельсы[ind].objects)
                {
                    if (!(obj4 is Ось)) continue;
                    var ось = (Ось)obj4;
                    if ((ось.передняя) || (ось.задняя))
                    {
                        //пропускаем других на стрелке, часть 3:
                        if (((ось.пройденное_расстояние_по_рельсу > (ось.текущий_рельс.Длина - ось.текущий_рельс.расстояние_добавочных_проводов - 10.0)) &&
                             (ось.трамвай.скорость != 0.0)) || (ось.задняя && ось.текущий_рельс != ось.трамвай.передняя_ось.текущий_рельс))// && (передняя_ось.пройденное_расстояние_по_рельсу < передняя_ось.текущий_рельс.расстояние_добавочных_проводов))
                        {
                            some_other_fucking_distance = Math.Min(some_other_fucking_distance, передняя_ось.текущий_рельс.Длина - передняя_ось.пройденное_расстояние_по_рельсу - (передняя_ось.текущий_рельс.расстояние_добавочных_проводов + 5.0));
                        }
                    }
                }*
            }*/
            var list = new List<Положение>(текущее_положение.Дорога.занятыеПоложения);
            //            List<Положение> list2 = new List<Положение>();
            //            if (рельс != null) list2 = new List<Положение>(рельс.занятыеПоложения);
            foreach (var положение in list)
            {
                if ((положение.comment == this) || (положение.расстояние <= текущее_положение.расстояние))
                    continue;
                if ((положение.comment != null) && (положение.comment is Трамвай))
                {
                    var comment = (Трамвай)положение.comment;
                    if (((comment.текущее_положение.Рельс != положение.Рельс) || (comment.задняя_ось.текущий_рельс != положение.Рельс)) && (comment.скорость == 0.0))
                        continue;
                }
                some_other_fucking_distance = Math.Min(some_other_fucking_distance, положение.расстояние - текущее_положение.расстояние - 2.0);
            }
            /*foreach (var положение2 in list2)
            {
                if (положение2.comment != this)
                {
                    some_other_fucking_distance = Math.Min(some_other_fucking_distance, (текущее_положение.Дорога.Длина - текущее_положение.расстояние) + положение2.расстояние - 2.0);
                }
            }*/
            /*foreach (var obj5 in передняя_ось.текущий_рельс.objects)
            {
                if (obj5 is Сигнальная_система.Сигнал)
                {
                    var сигнал = (Сигнальная_система.Сигнал)obj5;
                    if ((сигнал.система.сигнал == Сигналы.Красный) && ((сигнал.расстояние - передняя_ось.пройденное_расстояние_по_рельсу) > 10.0))
                    {
                        signals_dist = Math.Min(signals_dist, (сигнал.расстояние - передняя_ось.пройденное_расстояние_по_рельсу) - 30.0);
                    }
                }
                if (!(obj5 is Светофорный_сигнал)) continue;
                var сигнал2 = (Светофорный_сигнал)obj5;
                var num5 = сигнал2.расстояние - передняя_ось.пройденное_расстояние_по_рельсу;
                if (((сигнал2.сигнал == Сигналы.Красный) && (num5 > 5.0)) || ((сигнал2.сигнал == Сигналы.Жёлтый) && (num5 > 15.0)))
                {
                    signals_dist = Math.Min(signals_dist, num5 - 10.0);
                }
            }
            foreach (var obj6 in передняя_ось.текущий_рельс.следующие_рельсы[передняя_ось.текущий_рельс.следующий_рельс].objects)
            {
                if (obj6 is Сигнальная_система.Сигнал)
                {
                    var сигнал2 = (Сигнальная_система.Сигнал)obj6;
                    if (сигнал2.система.сигнал == Сигналы.Красный)
                    {
                        signals_dist = Math.Min(signals_dist, ((передняя_ось.текущий_рельс.Длина - передняя_ось.пройденное_расстояние_по_рельсу) + сигнал2.расстояние) - 30.0);
                    }
                }
                if (!(obj6 is Светофорный_сигнал)) continue;
                var сигнал21 = (Светофорный_сигнал)obj6;
                var num6 = (передняя_ось.текущий_рельс.Длина - передняя_ось.пройденное_расстояние_по_рельсу) + сигнал21.расстояние;
                if (((сигнал21.сигнал == Сигналы.Красный) && (num6 > 5.0)) || ((сигнал21.сигнал == Сигналы.Жёлтый) && (num6 > 15.0)))
                {
                    signals_dist = Math.Min(signals_dist, num6 - 10.0);
                }
            }*/
            var rec_speed7 = 15.0;
            var flag = false;
            /*var flag2 = false;
            if ((рейс != null) && (рейс.inPark || ((рейс.дорога_отправления == парк.выезд) && (мир.time < рейс.время_отправления))))
            {
                flag2 = true;
            }*/
            if ((рейс != null) && (рейс.inPark || ((рейс.дорога_отправления == парк.выезд) && (мир.time < рейс.время_отправления))))//(flag2)
            {
                foreach (Рельс рельс2 in парк.пути_стоянки)
                {
                    if (рельс2 != передняя_ось.текущий_рельс) continue;
                    flag = (скорость == 0.0);
                    var num8 = (рельс2.Длина - передняя_ось.пройденное_расстояние_по_рельсу) - 20.0;
                    signals_dist = Math.Min(signals_dist, num8);
                    ost_dist = Math.Min(ost_dist, num8);
                    break;
                }
            }
            if (flag && (base.система_управления.ход_или_тормоз <= 0))
            {
                токоприёмник.поднимается = false;
            }
            else
            {
                if (токоприёмник.Провод == null)
                {
                    токоприёмник.НайтиПровод(мир.контактныеПровода2);
                }
                else if (!токоприёмник.поднимается)
                {
                    токоприёмник.поднимается = true;
                }
            }
            ОткрытьДвери(false);
            var flag3 = (рейс == null) || (мир.time >= рейс.время_отправления);
            if (!flag3)
            {
                signals_dist = Math.Min(signals_dist, (передняя_ось.текущий_рельс.Длина - передняя_ось.пройденное_расстояние_по_рельсу) - 15.0);
            }
            base.stand_brake = flag;
            /*if (stops_dist < ost_dist)
            {
                ost_dist = stops_dist;
            }*/
            ost_dist = Math.Min(ost_dist, Math.Min(stops_dist, signals_dist));
            /*if (signals_dist < ost_dist)
            {
                ost_dist = signals_dist;
            }*/
            if (some_other_fucking_distance < ost_dist)
            {
                ost_dist = some_other_fucking_distance - 10.0;
            }
            if ((осталось_стоять > 0.0) && (stops_dist > 20.0))
            {
                rec_speed7 = 0.0;//-2.0;
                if (скорость_abs < 0.1)//(скорость == 0.0)
                {
                    base.stand_brake = true;
                    if (стоим_с_закрытыми_дверями)
                    {
                        if (!flag && flag3)
                        {
                            осталось_стоять -= World.прошлоВремени;
                            if (осталось_стоять <= 0.0)
                            {
                                стоим_с_закрытыми_дверями = false;
                            }
                        }
                    }
                    else
                    {
                        ОткрытьДвери(true);
                        if (двери_открыты && flag3)
                        {
                            осталось_стоять -= World.прошлоВремени;
                        }
                        if (nextStop == currentStop)
                        {
                            stopIndex++;
                            nextStop = null;
                            currentStop = null;
                        }
                    }
                }
            }
            else
            {
                if (ost_dist < 200.0)
                {
                    rec_speed7 = 12.0;
                }
                if (ost_dist < 80.0)
                {
                    rec_speed7 = 7.0;
                }
                if (ost_dist < 30.0)
                {
                    rec_speed7 = 4.0;
                }
                /*if (ost_dist < 10.0)
                {
                    rec_speed7 = 0.0;
                }*/
                if (stops_dist < 20.0)
                {
                    rec_speed7 = 1.5;
                    осталось_стоять = 8.0 + (Cheats._random.NextDouble() * 5.0);
                    if ((базоваяОстановка != null) && базоваяОстановка.serviceStop)
                    {
                        осталось_стоять = 1.0 + (Cheats._random.NextDouble() * 3.0);
                        стоим_с_закрытыми_дверями = true;
                    }
                }
                if (signals_dist < 10.0)
                {
                    rec_speed7 = -2.0;
                }
                if (some_other_fucking_distance < 15.0)
                {
                    rec_speed7 = -2.0;
                }
                /*if (some_other_fucking_distance < 0.0)
                {
                    if (позицияРеверсора > 0)
                    {
                        rec_speed7 = -2.0;
                        if (скорость == 0.0)
                        {
                            позицияРеверсора = -позицияРеверсора;
                        }
                    }
                    else
                    {
                        rec_speed7 = 7.0;
                    }
                }
                if ((позицияРеверсора < 0) && (some_other_fucking_distance > 0.0))
                {
                    rec_speed7 = -2.0;
                    if (скорость == 0.0)
                    {
                        позицияРеверсора = -позицияРеверсора;
                    }
                }*/
            }
            if (!двери_закрыты)
            {
                rec_speed7 = 0.0;
            }
            var index = 0;
            var sw = false;
            if (передняя_ось.текущий_рельс.следующие_рельсы.Length > 1)
            {
                //                var num11 = -1;
                index = Cheats._random.Next(2);
                if (рейс != null)
                {
                    for (var i = рейс_index; i < (рейс.pathes.Length - 1); i++)
                    {
                        if (рейс.pathes[i] != передняя_ось.текущий_рельс) continue;
                        if (рейс.pathes[i + 1] == передняя_ось.текущий_рельс.следующие_рельсы[0])
                        {
                            index = 0;
                        }
                        else if (рейс.pathes[i + 1] == передняя_ось.текущий_рельс.следующие_рельсы[1])
                        {
                            index = 1;
                        }
                        break;
                    }
                }
                /*if (num11 == -1)
                {
                    num11 = Cheats._random.Next(2);
                }
                index = num11;*/
                var num13 = передняя_ось.текущий_рельс.Длина - передняя_ось.пройденное_расстояние_по_рельсу;
                var рельс3 = передняя_ось.текущий_рельс.следующие_рельсы[index];
                if ((num13 < 30.0) && рельс3.кривая)
                {
                    указатель_поворота = (рельс3.СтепеньПоворота0 > 0.0) ? 1 : -1;
                    sw = true;
                }
                /*else if (передняя_ось.текущий_рельс == задняя_ось.текущий_рельс)
                {
                    указатель_поворота = 0;
                }*/
            }
            if (((flag || (осталось_стоять > 20.0)) || (!flag3 && (скорость == 0.0))) || ((передняя_ось.текущий_рельс == задняя_ось.текущий_рельс) && (!sw)))
            {
                указатель_поворота = 0;
            }
            система_управления.автоматически_управлять(rec_speed7, ost_dist, index);
        }

        public bool возможно_переключение
        {
            get
            {
                /*if (токоприёмник.поднят && (передняя_ось.текущий_рельс.следующие_рельсы.Length > 1))
                {
                    DoublePoint point = координаты_токоприёмника - передняя_ось.текущий_рельс.добавочные_провода.координаты;
                    if (point.модуль < 0.5)
                    {
                        return true;
                    }
                }
                return false;*/
                return base.система_управления.переключение;
            }
        }

        public abstract Ось[] все_оси { get; }

        public abstract Ось задняя_ось { get; }

        public abstract Ось передняя_ось { get; }

        public abstract Double3DPoint координаты_токоприёмника { get; }

        //        public abstract double направление_токоприёмника { get; }

        public abstract Matrix преобразование_токоприёмника { get; }

        public override Положение текущее_положение
        {
            get
            {
                return new Положение(передняя_ось.текущий_рельс, передняя_ось.пройденное_расстояние_по_рельсу);
            }
        }

        /// <summary>
        /// На основе ЛМ-68М
        /// </summary>
        public class ОбычныйТрамвай : Трамвай, IVector, IОбъектПривязки3D
        {
            //            private int[] frequency = new int[3];
            //            private int[] volume = new int[3];
            //            private int volume_muting;
            public Вагон вагон;
            public БазовыйВагон[] хвосты;
            private double axis_radius;
            //            public double времяПоворотников;
            //            public double времяПоворотниковMax = 1.0;
            //            public double времяПоворотниковВыкл = 0.5;
            //            public Трамвай.Маршрутный_Указатель маршрутный_указатель;
            //            public double расстояние_между_вагонами = 16.5;
            //            public double расстояние_между_тележками = 7.5;// 7.5;
            public double расстояние_между_осями = 1.94;//1.94
                                                        //            public Трамвай.ТабличкаВПарк табличка_в_парк;
                                                        //            public Сочленение[] сочленения;
            public Сочленение_new[] сочленения2 = new Сочленение_new[0];
            public Дополнение[] дополнения = new Дополнение[0];

            public ОбычныйТрамвай(МодельТранспорта модель, Рельс рельс, double расстояние_по_рельсу, Управление управление, Парк парк, Route маршрут, Order наряд)//, bool test)//, int количество_вагонов)
            {
                this.модель = модель;
                основная_папка = модель.dir;
                this.наряд = наряд;
                //                this.расстояние_между_тележками = модель.расстояние_между_тележками;
                this.расстояние_между_осями = модель.расстояние_между_осями;
                this.axis_radius = модель.axis_radius;
                var num = 0.0;
                this.тележки = new Трамвай.Тележка[модель.тележки.Length];
                for (int i = 0; i < this.тележки.Length; i++)
                {
                    if ((модель.тележки[i].index > 0) && (модель.тележки[i].index != модель.тележки[i - 1].index)) num += модель.tails[модель.тележки[i].index - 1].dist;
                    this.тележки[i] = new Трамвай.Тележка(рельс, расстояние_по_рельсу, модель.тележки[0].dist - модель.тележки[i].dist + ((модель.тележки[i].index > 0) ? /*модель.tails[модель.тележки[i].index - 1].dist*/num : 0), axis_radius, this);
                }
                /*                this.расстояние_между_вагонами = модель.расстояние_между_вагонами;
                                this.тележки = new Трамвай.Тележка[модель.количество_вагонов * 2];
                                for (int i = 0; i < this.тележки.Length; i++)
                                {
                                    this.тележки[i] = new Трамвай.Тележка(рельс, (расстояние_по_рельсу - (расстояние_между_вагонами * i)) - расстояние_между_тележками, this);
                                }
                 */
                вагон = new Вагон(this);//, new Трамвай.Тележка(рельс, расстояние_по_рельсу, 0.0f, axis_radius, this), new Трамвай.Тележка(рельс, расстояние_по_рельсу, расстояние_между_тележками, axis_radius, this));
                                        //                this.сочленения = new Сочленение[модель.количествоХвостов];
                this.хвосты = new БазовыйВагон[модель.tails.Length];//количествоХвостов];
                for (int z = 0; z < this.хвосты.Length; z++)
                {
                    this.хвосты[z] = new Задний_Вагон(this);//, new Трамвай.Тележка(рельс, расстояние_по_рельсу, (модель.tails[z].dist * (z + 1)), axis_radius, this), new Трамвай.Тележка(рельс, расстояние_по_рельсу, (модель.tails[z].dist * (z + 1)) + модель.tails[z].t_dist, axis_radius, this));
                    /*if (z == 0)
                    {
                        this.сочленения[z] = new Сочленение(this, вагон.передняя_тележка, хвосты[z].задняя_тележка, вагон.задняя_тележка, модель.tails[z].have);
                    }
                    else
                    {
                        this.сочленения[z] = new Сочленение(this, хвосты[z - 1].передняя_тележка, хвосты[z].задняя_тележка, хвосты[z - 1].задняя_тележка, модель.tails[z].have);
                   }*/
                }
                try
                {
                    this.сочленения2 = new Сочленение_new[модель.сочленения.Length];//количествоСочленений];
                    for (int k = 0; k < this.сочленения2.Length; k++)
                    {
                        this.сочленения2[k] = new Сочленение_new(/*k,*/ this, модель.сочленения[k].index, модель.сочленения[k].target, модель.сочленения[k].dist);
                    }
                }
                catch { };
                //                this.сочленения2[0] = new Сочленение_new(this, 0, 1, 3.456);
                //                vs = модель.пантограф.pos.y + 1.5;
                //                маршрутный_указатель = new Трамвай.Маршрутный_Указатель();
                указатель_наряда = new УказательНаряда();
                табличка_в_парк = new ТабличкаВПарк(this);
                this.управление = управление;
                this.маршрут = маршрут;
                this.парк = парк;
                //                токоприёмник = Токоприёмник.Build(модель.пантограф);
                токоприёмник = new Токоприёмник_new.Пантограф(this, модель.пантограф.pos.y, модель.пантограф.pos.y + модель.пантограф.min_height, модель.пантограф.pos.y + модель.пантограф.max_height);//модель.пантограф.pos, this.Найти_часть(0));
                /*токоприёмник.трамвай = this;
                токоприёмник.части = new Трамвай.Токоприёмник_new.Часть[модель.пантограф.parts.Length];
                for (int i = 0; i < токоприёмник.части.Length; i++)
                {
                    токоприёмник.части[i] = new Трамвай.Токоприёмник_new.Часть(токоприёмник, модель.пантограф.parts[i].filename, модель.пантограф.parts[i].index, модель.пантограф.parts[i].height, модель.пантограф.parts[i].width, модель.пантограф.parts[i].length);
                }
                токоприёмник.высота_основания = модель.пантограф.pos.y;
                токоприёмник.высота_min = токоприёмник.высота_основания + токоприёмник.части[0].height;//0.65;
                токоприёмник.width = токоприёмник.части[токоприёмник.части.Length - 1].width / 2.0;*/
                дополнения = new Дополнение[модель.дополнения.Length];
                for (int j = 0; j < модель.дополнения.Length; j++)
                {
                    this.дополнения[j] = new Дополнение(this.Найти_часть(модель.дополнения[j].часть), модель.дополнения[j].filename, модель.дополнения[j].тип);
                }
                _количествоДверей = модель.количествоДверей;
                _двери = new Двери[модель.двери.Length];
                for (var n = 0; n < модель.двери.Length; n++)
                {
                    _двери[n] = Двери.Построить(модель.двери[n].модель, Найти_часть(модель.двери[n].часть), модель.двери[n].p1, модель.двери[n].p2, модель.двери[n].правые);
                    _двери[n].дверьВодителя = модель.двери[n].дверьВодителя;
                    _двери[n].номер = модель.двери[n].номер;
                }
                система_управления = Система_управления.Parse(модель.системаУправления, this);
                if (!модель.hasnt_bbox)
                {
                    /*вагон.bounding_box = new AABB(модель.bbox[0], модель.bbox[1]);//new Double3DPoint(-(расстояние_между_тележками / 2.0 + 4.0), 0.0, -2.5), new Double3DPoint(расстояние_между_тележками / 2.0 + 4.0, 3.0, 2.5));
                    for (int k = 0; k < this.хвосты.Length; k++)
                    {
                        хвосты[k].bounding_box = new AABB(модель.tails_bbox[k][0], модель.tails_bbox[k][1]);// new Double3DPoint(-(tail_telegi_dist / 2.0 + 4.0), 0.0, -2.5), new Double3DPoint(tail_telegi_dist / 2.0 + 4.0, 3.0, 2.5));
                    }*/
                    вагон.bounding_sphere = new Sphere(модель.bsphere.pos, модель.bsphere.radius);
                    for (var i = 0; i < хвосты.Length; i++)
                    {
                        хвосты[i].bounding_sphere = new Sphere(модель.tails_bsphere[i].pos, модель.tails_bsphere[i].radius);
                    }
                }
                else
                {
                    /*вагон.bounding_box = new AABB(new Double3DPoint(-(расстояние_между_тележками / 2.0 + 4.0), 0.0, -2.5), new Double3DPoint(расстояние_между_тележками / 2.0 + 4.0, 3.0, 2.5));
                    for (int k = 0; k < this.хвосты.Length; k++)
                    {
                         хвосты[k].bounding_box = new AABB(new Double3DPoint(-(модель.tails[k].t_dist / 2.0 + 4.0), 0.0, -2.5), new Double3DPoint(модель.tails[k].t_dist / 2.0 + 4.0, 3.0, 2.5));
                     }*/
                    вагон.bounding_sphere = new Sphere(Double3DPoint.Zero, 10.0);
                    for (var i = 0; i < хвосты.Length; i++)
                    {
                        хвосты[i].bounding_sphere = new Sphere(Double3DPoint.Zero, 10.0);
                    }
                }
                for (int i = 0; i < модель.занятыеПоложения.Length; i++)
                {
                    width = Math.Max(width, Math.Abs(модель.занятыеПоложения[i].y));
                    length0 = Math.Max(length0, Math.Abs(модель.занятыеПоложения[i].x));
                    length1 = Math.Min(length1, модель.занятыеПоложения[i].x);
                }
                length1 = -length1;
                if (модель.занятыеПоложенияХвостов.Length > 0)
                {
                    length1 = 0.0;
                    for (int i = 0; i < модель.занятыеПоложенияХвостов[модель.занятыеПоложенияХвостов.Length - 1].Length; i++)
                    {
                        length1 = Math.Max(length1, Math.Abs(модель.занятыеПоложенияХвостов[модель.занятыеПоложенияХвостов.Length - 1][i].x));
                    }
                    length1 += num;
                }
                LoadCameras();
            }

            public override void CreateMesh(World мир)
            {
                if (мир.filename != null)
                {
                    //var strArray = парк==null?
                    var strArray = new[]
                            {
                                            Application.StartupPath + @"\Cities\" +
                                            Path.GetFileNameWithoutExtension(мир.filename) + @"\" + парк.название + @"\",
                                            Application.StartupPath + @"\Cities\" +
                                            Path.GetFileNameWithoutExtension(мир.filename) + @"\"
                            };
                    вагон.extraMeshDirs = strArray;
                    //маршрутный_указатель.extraMeshDirs = strArray;
                    указатель_наряда.extraMeshDirs = strArray;
                    табличка_в_парк.extraMeshDirs = strArray;
                    //                токоприёмник.extraMeshDirs = strArray;
                    //                токоприёмник.дуга.extraMeshDirs = strArray;
                    foreach (Двери дверь in _двери)
                    {
                        дверь.ExtraMeshDirs = strArray;
                    }
                    foreach (Трамвай.ОбычныйТрамвай.БазовыйВагон tail in хвосты)
                    {
                        tail.extraMeshDirs = strArray;
                    }
                    /*foreach (Трамвай.ОбычныйТрамвай.Сочленение middle in сочленения)
                    {
                           if (!middle._has) continue;
                           middle.extraMeshDirs = strArray;
                    }*/
                }
                foreach (var тележка in this.тележки)
                {
                    тележка.CreateMesh();
                    foreach (var axis in тележка.оси)
                    {
                        axis.CreateMesh();
                    }
                }
                foreach (Трамвай.ОбычныйТрамвай.БазовыйВагон tail in this.хвосты)
                {
                    tail.CreateMesh();
                    //
                    /*tail.передняя_тележка.CreateMesh();
                    tail.задняя_тележка.CreateMesh();
                       tail.передняя_тележка.оси[0].CreateMesh();
                    tail.передняя_тележка.оси[1].CreateMesh();
                    tail.задняя_тележка.оси[0].CreateMesh();
                    tail.задняя_тележка.оси[1].CreateMesh();*/
                    //
                    /*foreach (var telega in tail.тележки)
                    {
                        if (telega == null) continue;
                        telega.CreateMesh();
                        telega.оси[0].CreateMesh();
                        telega.оси[1].CreateMesh();
                    }*/
                    tail.Обновить_маршрутный_указатель(маршрут.number, наряд.номер);
                }
                /*foreach (Трамвай.ОбычныйТрамвай.Сочленение middle in сочленения)
                {
                    if (!middle._has) continue;
                    middle.CreateMesh();
                }*/
                foreach (var middle2 in сочленения2)
                {
                    middle2.CreateMesh();
                }
                вагон.CreateMesh();
                //
                /*вагон.передняя_тележка.CreateMesh();
                вагон.задняя_тележка.CreateMesh();
                вагон.передняя_тележка.оси[0].CreateMesh();
                вагон.передняя_тележка.оси[1].CreateMesh();
                вагон.задняя_тележка.оси[0].CreateMesh();
                вагон.задняя_тележка.оси[1].CreateMesh();*/
                //
                /*foreach (var telega in вагон.тележки)
                {
                    if (telega == null) continue;
                    telega.CreateMesh();
                    telega.оси[0].CreateMesh();
                    telega.оси[1].CreateMesh();
                }*/
                токоприёмник.CreateMesh();
                //            токоприёмник.дуга.CreateMesh();
                foreach (var дополнение in дополнения)
                {
                    дополнение.CreateMesh();
                }
                //            маршрутный_указатель.CreateMesh();
                //            маршрутный_указатель.Обновить(маршрут.number);
                вагон.Обновить_маршрутный_указатель(маршрут.number, наряд.номер);
                указатель_наряда.CreateMesh();
                if (наряд != null)
                {
                    указатель_наряда.ОбновитьКартинку(наряд);
                }
                табличка_в_парк.CreateMesh();
                foreach (Двери двери2 in _двери)
                {
                    двери2.CreateMesh();
                }
                /*          foreach (Трамвай трамвай in вагоны)
                              {
                                  трамвай.CreateMesh(мир);
                              }
                */
            }

            protected override void CheckCondition()
            {
                var cnd = !base.condition;
                вагон.IsNear = cnd;
                foreach (var tail in this.хвосты)
                {
                    tail.IsNear = cnd;
                }
                if (!cnd) return;
                токоприёмник.CheckCondition();
                foreach (var тележка in this.тележки)
                {
                    тележка.IsNear = cnd;
                    foreach (var axis in тележка.оси)
                    {
                        axis.IsNear = cnd;
                    }
                }
                foreach (var middle2 in сочленения2)
                {
                    middle2.IsNear = cnd;
                }
                foreach (var дополнение in дополнения)
                {
                    дополнение.IsNear = cnd;
                }
                if (наряд != null)
                {
                    указатель_наряда.IsNear = cnd;
                }
                табличка_в_парк.IsNear = cnd;
                foreach (var двери in _двери)
                {
                    двери.CheckCondition();
                }
            }

            public override void Render()
            {
                CheckCondition();
                if (condition) return;
                var visible = false;
                var lod = 2;
                if (MyDirect3D.SphereInFrustum(вагон.bounding_sphere))//(MyDirect3D.AABBInFrustum(вагон.bounding_box))
                {
                    visible = true;
                    вагон.Render();
                    lod = Math.Min(вагон.bounding_sphere.LODnum, lod);
                    //
                    /*вагон.передняя_тележка.Render();
                    вагон.задняя_тележка.Render();
                    вагон.передняя_тележка.оси[0].Render();
                    вагон.передняя_тележка.оси[1].Render();
                    вагон.задняя_тележка.оси[0].Render();
                    вагон.задняя_тележка.оси[1].Render();*/
                    //
                    /*foreach (var telega in вагон.тележки)
                    {
//                    if (telega == null) continue;
                        telega.Render();
                        telega.оси[0].Render();
                        telega.оси[1].Render();
                    }*/
                }
                foreach (Трамвай.ОбычныйТрамвай.БазовыйВагон tail in this.хвосты)
                {
                    //if (!MyDirect3D.AABBInFrustum(tail.bounding_box)) continue;
                    if (!MyDirect3D.SphereInFrustum(tail.bounding_sphere)) continue;
                    visible = true;
                    tail.Render();
                    lod = Math.Min(tail.bounding_sphere.LODnum, lod);
                    //
                    /*tail.передняя_тележка.Render();
                    tail.задняя_тележка.Render();
                       tail.передняя_тележка.оси[0].Render();
                    tail.передняя_тележка.оси[1].Render();
                    tail.задняя_тележка.оси[0].Render();
                    tail.задняя_тележка.оси[1].Render();*/
                    //
                    /*foreach (var telega in tail.тележки)
                    {
//                        if (telega == null) continue;
                        telega.Render();
                        telega.оси[0].Render();
                        telega.оси[1].Render();
                    }*/
                }
                if ((!visible) || (lod > 0)) return;
                токоприёмник.Render();
                /*токоприёмник.дуга.Render();
                foreach (Трамвай.ОбычныйТрамвай.Сочленение middle in сочленения)
                {
                    if (!middle._has) continue;
                    middle.Render();
                }*/
                foreach (var тележка in this.тележки)
                {
                    тележка.Render();
                    foreach (var axis in тележка.оси)
                    {
                        axis.Render();
                    }
                }
                foreach (var middle2 in сочленения2)
                {
                    middle2.Render();
                }
                foreach (var дополнение in дополнения)
                {
                    if ((дополнение.тип == Тип_дополнения.фары) && включены_фары)
                    {
                        дополнение.Render();
                    }
                    if (времяПоворотников < времяПоворотниковВыкл)
                    {
                        if ((дополнение.тип == Тип_дополнения.влево) && ((указатель_поворота < 0) || аварийная_сигнализация))
                        {
                            дополнение.Render();
                        }
                        if ((дополнение.тип == Тип_дополнения.вправо) && ((указатель_поворота > 0) || аварийная_сигнализация))
                        {
                            дополнение.Render();
                        }
                    }
                    if ((дополнение.тип == Тип_дополнения.тормоз) && (система_управления.ход_или_тормоз < 0))
                    {
                        дополнение.Render();
                    }
                    if ((дополнение.тип == Тип_дополнения.назад) && (система_управления.направление < 0))
                    {
                        дополнение.Render();
                    }
                }
                //                маршрутный_указатель.matrix = Matrix.Translation(1.756f, 1.05f, -1.3f) * вагон.GetMatrix(0);
                //                маршрутный_указатель.Render();
                if (наряд != null)
                {
                    указатель_наряда.matrix = Matrix.Translation((float)модель.нарядPos.x, (float)модель.нарядPos.y, (float)модель.нарядPos.z) * вагон.last_matrix;//.GetMatrix(0);
                    указатель_наряда.Render();
                }
                табличка_в_парк.matrix = Matrix.Translation((float)модель.табличка.pos.x, (float)модель.табличка.pos.y, (float)модель.табличка.pos.z) * вагон.last_matrix;//.GetMatrix(0); //(7.65f, 2.26f, -0.42f) * вагон.GetMatrix(0);
                табличка_в_парк.Render();
                foreach (var двери in _двери)
                {
                    двери.Render();
                }
            }

            public override void UpdateBoundigBoxes(World world)
            {
                //                if (!world.simple_timer.flag) return;
                /*foreach (var хвост in хвосты)
                {
                    хвост.bounding_box.Update(хвост.Координаты3D, хвост.направление);
                }
                вагон.bounding_box.Update(вагон.Координаты3D, вагон.направление);*/
                вагон.bounding_sphere.Update(вагон.Координаты3D, вагон.направление);
                foreach (var хвост in хвосты)
                {
                    хвост.bounding_sphere.Update(хвост.Координаты3D, хвост.направление);
                }
            }

            /*public override void UpdateSound(Игрок[] игроки, bool игра_активна)
            {
                base.система_управления.UpdateSound(игроки, игра_активна);
            }*/

            public ЧастьТрамвая Найти_часть(int index)
            {
                if (index > 0)
                {
                    return хвосты[index - 1];
                }
                if (index < 0)
                {
                    return this.сочленения2[-index - 1];
                }
                return this.вагон;
            }

            public override Положение[] НайтиВсеПоложения(World мир)
            {
                //                var list = new List<Положение>();//
                base.найденные_положения.Clear();
                var point = new Double3DPoint(this.вагон.направление);
                var point2 = Double3DPoint.Rotate(this.вагон.направление, (Math.PI / 2.0));
                int length = this.модель.занятыеПоложения.Length;
                for (int i = 0; i < this.модель.занятыеПоложенияХвостов.Length; i++)
                {
                    length += this.модель.занятыеПоложенияХвостов[i].Length;
                }
                var pos = new Double3DPoint[length];
                int index = 0;
                int num4 = 0;
                while (num4 < this.модель.занятыеПоложения.Length)
                {
                    pos[index] = (Double3DPoint)((this.вагон.Координаты3D + (point * this.модель.занятыеПоложения[num4].x)) + (point2 * this.модель.занятыеПоложения[num4].y));
                    num4++;
                    index++;
                }
                for (int j = 0; j < this.модель.занятыеПоложенияХвостов.Length; j++)
                {
                    point = new Double3DPoint(this.хвосты[j].направление);
                    point2 = Double3DPoint.Rotate(this.хвосты[j].направление, (Math.PI / 2.0));
                    int num6 = 0;
                    while (num6 < this.модель.занятыеПоложенияХвостов[j].Length)
                    {
                        pos[index] = (Double3DPoint)((this.хвосты[j].Координаты3D + (point * this.модель.занятыеПоложенияХвостов[j][num6].x)) + (point2 * this.модель.занятыеПоложенияХвостов[j][num6].y));
                        num6++;
                        index++;
                    }
                }
                var collection = мир.Найти_все_положения(pos);
                for (var i = 0; i < collection.Length; i++)
                {
                    collection[i].comment = this;
                }
                base.найденные_положения.AddRange(collection);
                //                найденные_положения = list;
                return base.найденные_положения.ToArray();
            }

            public override void Обновить(World мир, Игрок[] игроки_в_игре)
            {
                var list = new List<Игрок>();
                if (игроки_в_игре != null)
                {
                    for (int i = 0; i < игроки_в_игре.Length; i++)
                    {
                        if (игроки_в_игре[i].объектПривязки == this)
                        {
                            list.Add(игроки_в_игре[i]);
                        }
                    }
                }
                var num2 = скорость;
                if (list.Count > 0)
                {
                    IОбъектПривязки3D[] иDArray = new IОбъектПривязки3D[list.Count];
                    int index = 0;
                    int num3;
                    foreach (Игрок игрок in list)
                    {
                        double[] numArray = new double[this.хвосты.Length];
                        num3 = 0;
                        while (num3 < this.хвосты.Length)
                        {
                            DoublePoint point = игрок.cameraPosition.XZPoint - this.хвосты[num3].position;
                            numArray[num3] = point.Modulus;
                            num3++;
                        }
                        double[] numArray2 = new double[this.сочленения2.Length];
                        num3 = 0;
                        while (num3 < this.сочленения2.Length)
                        {
                            DoublePoint point2 = игрок.cameraPosition.XZPoint - this.сочленения2[num3].position;
                            numArray2[num3] = point2.Modulus;
                            num3++;
                        }
                        bool flag = false;
                        num3 = 0;
                        while (num3 < this.сочленения2.Length)
                        {
                            if (numArray2[num3] < 1.0)
                            {
                                иDArray[index] = this.сочленения2[num3];
                                flag = true;
                                break;
                            }
                            num3++;
                        }
                        if (!flag)
                        {
                            иDArray[index] = this.вагон;
                            var point3 = игрок.cameraPosition.XZPoint - this.вагон.Координаты3D.XZPoint;
                            var num5 = point3.Modulus;
                            for (num3 = 0; num3 < this.хвосты.Length; num3++)
                            {
                                if (numArray[num3] < num5)
                                {
                                    num5 = numArray[num3];
                                    иDArray[index] = this.хвосты[num3];
                                }
                            }
                        }
                        index++;
                    }
                    var pointArray = new Double3DPoint[list.Count];
                    var pointArray2 = new Double3DPoint[list.Count];
                    var pointArray3 = new Double3DPoint[list.Count];
                    var pointArray4 = new DoublePoint[list.Count];
                    var pointArray5 = new DoublePoint[list.Count];
                    index = 0;
                    foreach (var игрок2 in list)
                    {
                        pointArray[index] = игрок2.cameraPosition - иDArray[index].Координаты3D;
                        pointArray[index].XZPoint = pointArray[index].XZPoint.Multyply(new DoublePoint(-иDArray[index].direction));
                        pointArray[index].XYPoint = pointArray[index].XYPoint.Multyply(new DoublePoint(-иDArray[index].НаправлениеY));
                        pointArray2[index] = игрок2.поворачиватьКамеру ? игрок2.cameraPosition : иDArray[index].Координаты3D;
                        pointArray4[index] = new DoublePoint(иDArray[index].direction, иDArray[index].НаправлениеY);
                        index++;
                    }
                    Передвинуть(скорость * World.прошлоВремени, мир);
                    index = 0;
                    foreach (Игрок игрок3 in list)
                    {
                        pointArray[index].XYPoint = pointArray[index].XYPoint.Multyply(new DoublePoint(иDArray[index].НаправлениеY));
                        pointArray[index].XZPoint = pointArray[index].XZPoint.Multyply(new DoublePoint(иDArray[index].direction));
                        pointArray[index].Add(иDArray[index].Координаты3D);
                        pointArray3[index] = игрок3.поворачиватьКамеру ? pointArray[index] : иDArray[index].Координаты3D;
                        pointArray5[index] = new DoublePoint(иDArray[index].direction, иDArray[index].НаправлениеY);
                        игрок3.cameraPosition.Add(pointArray3[index] - pointArray2[index]);
                        if (игрок3.поворачиватьКамеру)
                        {
                            игрок3.cameraRotation.Add(pointArray5[index] - pointArray4[index]);
                        }
                        index++;
                    }
                }
                else
                {
                    Передвинуть(скорость * World.прошлоВремени, мир);
                }
                //                токоприёмник.position = вагон.Координаты3D + ((Double3DPoint)(new Double3DPoint(вагон.направление) * модель.пантограф.pos.x));
                токоприёмник.Обновить(мир);
                this.времяПоворотников += World.прошлоВремени;
                while (this.времяПоворотников > this.времяПоворотниковMax)
                {
                    this.времяПоворотников -= this.времяПоворотниковMax;
                }
                if ((base.указатель_поворота != this._бывшийУказательПоворота) || (base.аварийная_сигнализация != this._былаАварийнаяСигнализация))
                {
                    this.времяПоворотников = 0.0;
                }
                this._бывшийУказательПоворота = base.указатель_поворота;
                this._былаАварийнаяСигнализация = base.аварийная_сигнализация;
                _soundУскоряется = false;
                _soundЗамедляется = false;
                if ((base.система_управления.ход_или_тормоз != 0) && токоприёмник.поднят)
                {
                    double last_speed = скорость;
                    скорость += ускорение * World.прошлоВремени;
                    if (base.система_управления.ход_или_тормоз > 0)
                    {
                        _soundУскоряется = true;
                    }
                    else if (base.система_управления.ход_или_тормоз < 0)// && (скорость >= 1.0))
                    {
                        if ((скорость * last_speed) < 0.0)
                        {
                            скорость = 0.0;
                        }
                        _soundЗамедляется = true;
                    }
                }
                if (возможно_переключение)
                {
                    var cond = ((base.система_управления.ход_или_тормоз <= 0) != Рельс.стрелки_наоборот);
                    /*if ((base.система_управления.ход_или_тормоз <= 0) != Рельс.стрелки_наоборот)// && (позицияКонтроллера > -5)
                    {
                        передняя_ось.текущий_рельс.следующий_рельс = 0;
                        foreach (Рельс рельс in передняя_ось.текущий_рельс.соседние_рельсы)
                        {
                            рельс.следующий_рельс = 0;
                        }
                    }
                    else
                    {
                        передняя_ось.текущий_рельс.следующий_рельс = 1;
                        foreach (Рельс рельс2 in передняя_ось.текущий_рельс.соседние_рельсы)
                        {
                            рельс2.следующий_рельс = 1;
                        }
                    }*/
                    передняя_ось.текущий_рельс.следующий_рельс = cond ? 0 : 1;
                    foreach (Рельс рельс2 in передняя_ось.текущий_рельс.соседние_рельсы)
                    {
                        рельс2.следующий_рельс = cond ? 0 : 1;
                    }
                }
                if ((передняя_ось.текущий_рельс.высота[0] == передняя_ось.текущий_рельс.высота[1]) && !передняя_ось.в_обратную_сторону)
                {
                    var рельс3 = передняя_ось.текущий_рельс;
                    var num5 = передняя_ось.пройденное_расстояние_по_рельсу;
                    for (int i = 0; i < тележки.Length; i++)
                    {
                        if (num5 < тележки[i].default_dist + расстояние_между_осями) continue;
                        тележки[i].оси[0].cменить_текущий_рельс(рельс3);
                        тележки[i].оси[0].пройденное_расстояние_по_рельсу = num5 - тележки[i].default_dist;
                        тележки[i].оси[1].cменить_текущий_рельс(рельс3);
                        тележки[i].оси[1].пройденное_расстояние_по_рельсу = num5 - тележки[i].default_dist - расстояние_между_осями;
                    }
                }
                foreach (var дверь in base._двери)
                {
                    дверь.Обновить();
                }
                base.скорость_abs -= 0.1 * World.прошлоВремени;
                base.ОбновитьРейс();
                this.UpdateBoundigBoxes(мир);
            }

            protected override void ОбновитьМаршрутныеУказатели()
            {
                вагон.Обновить_маршрутный_указатель(маршрут.number, наряд == null ? "" : наряд.номер);
                foreach (var tail in хвосты)
                {
                    tail.Обновить_маршрутный_указатель(маршрут.number, наряд == null ? "" : наряд.номер);
                }
                //                маршрутный_указатель.Обновить(маршрут.number);
            }

            public override void SetPosition(Road road, double distance, double shift, Double3DPoint pos, DoublePoint rot, World world)
            {
                for (int i = 0; i < this.тележки.Length; i++)
                {
                    this.тележки[i].оси[0].текущий_рельс = (Рельс)road;
                    this.тележки[i].оси[1].текущий_рельс = (Рельс)road;
                    this.тележки[i].оси[0].пройденное_расстояние_по_рельсу = distance - this.тележки[i].default_dist;
                    this.тележки[i].оси[1].пройденное_расстояние_по_рельсу = distance - this.тележки[i].default_dist - расстояние_между_осями;
                }
            }

            public override void Передвинуть(double расстояние, World мир)
            {
                /*вагон.передняя_тележка.оси[0].передвинуть(расстояние);
                вагон.передняя_тележка.оси[1].передвинуть(расстояние);
                вагон.задняя_тележка.оси[0].передвинуть(расстояние);
                вагон.задняя_тележка.оси[1].передвинуть(расстояние);
                for (int i = 0; i < this.хвосты.Length; i++)
                {
                    хвосты[i].передняя_тележка.оси[0].передвинуть(расстояние);
                    хвосты[i].передняя_тележка.оси[1].передвинуть(расстояние);
                    хвосты[i].задняя_тележка.оси[0].передвинуть(расстояние);
                    хвосты[i].задняя_тележка.оси[1].передвинуть(расстояние);
                }*/
                /**/
                var pos = new Double3DPoint[1 + this.хвосты.Length];
                var dir = new DoublePoint[1 + this.хвосты.Length];
                //                var flag = false;
                for (int i = 0; i < тележки.Length; i++)
                {
                    for (int j = 0; j < тележки[i].оси.Length; j++)
                    {
                        тележки[i].оси[j].Передвинуть(расстояние);
                    }
                }
                for (int i = 0; i < тележки.Length; i++)
                {
                    if ((i < тележки.Length - 1) && (модель.тележки[i].index == модель.тележки[i + 1].index))
                    {
                        //                        var p = тележки[i].координаты_3D - тележки[i+1].координаты_3D;
                        dir[модель.тележки[i].index] = (тележки[i].координаты_3D - тележки[i + 1].координаты_3D).Angle;
                        pos[модель.тележки[i].index] = тележки[i].координаты_3D + (new Double3DPoint(dir[модель.тележки[i].index]).Multyply(-модель.тележки[i].dist));
                        i++;
                        continue;
                    }
                    dir[модель.тележки[i].index] = new DoublePoint(модель.тележки[i].dist, 0.0);
                    pos[модель.тележки[i].index] = тележки[i].координаты_3D;
                }
                if (тележки.Length == 1) dir[0] = тележки[0].координаты_3D.Angle;

                Double3DPoint point1;
                DoublePoint point01;
                Double3DPoint point2;
                DoublePoint point02;
                for (int k = 0; k < this.сочленения2.Length; k++)
                {
                    сочленения2[k]._Координаты3D = pos[сочленения2[k]._index] + (new Double3DPoint(dir[сочленения2[k]._index]).Multyply(-сочленения2[k].dist));
                    var x = dir[сочленения2[k]._target].x;
                    if (сочленения2[k]._index > сочленения2[k]._target)
                    {
                        var p = pos[сочленения2[k]._target] - сочленения2[k]._Координаты3D;
                        dir[сочленения2[k]._target] = p.Angle;
                        pos[сочленения2[k]._target].Add(new Double3DPoint(dir[сочленения2[k]._target]).Multyply(-x));
                    }
                    else
                    {
                        var p = сочленения2[k]._Координаты3D - pos[сочленения2[k]._target];
                        dir[сочленения2[k]._target] = p.Angle;
                        pos[сочленения2[k]._target].Add(new Double3DPoint(dir[сочленения2[k]._target]).Multyply(-x));
                    }
                    point1 = pos[сочленения2[k]._index] - сочленения2[k].Координаты3D;
                    point01 = point1.Angle;
                    point2 = сочленения2[k].Координаты3D - pos[сочленения2[k]._target];
                    point02 = point2.Angle;
                    сочленения2[k]._direction.x = (point01.x + point02.x) / 2.0;
                    сочленения2[k]._direction.y = (point01.y + point02.y) / 2.0;
                    if (Math.Abs(point01.x - point02.x) >= Math.PI)
                    {
                        сочленения2[k]._direction.x += Math.PI;
                    }
                    if (Math.Abs(point01.y - point02.y) >= Math.PI)
                    {
                        сочленения2[k]._direction.y += Math.PI;
                    }
                    //                    point2 = new Double3DPoint(this.сочленения2[k].направление);
                    //                    point2.угол_y += 1.5707963267948966;
                    //                    сочленения2[k].координаты -= (Double3DPoint)(point2 * (axis_radius * 2));
                }
                вагон._Координаты3D = pos[0];
                вагон._direction = dir[0];
                for (int j = 1; j < pos.Length; j++)
                {
                    хвосты[j - 1]._Координаты3D = pos[j];
                    хвосты[j - 1]._direction = dir[j];
                }
                /*///комментить отсюда
                foreach (var telega in вагон.тележки)
                {
                    telega.оси[0].передвинуть(расстояние);
                    telega.оси[1].передвинуть(расстояние);
                }
                for (int i = 0; i < this.хвосты.Length; i++)
                {
                    foreach (var telega2 in хвосты[i].тележки)
                    {
                        telega2.оси[0].передвинуть(расстояние);
                        telega2.оси[1].передвинуть(расстояние);
                    }
                }
                if (this.сочленения2.Length == 0) return;
                Double3DPoint point1;
                DoublePoint point01;
                Double3DPoint point2;
                DoublePoint point02;
                for (int k = 0; k < this.сочленения2.Length; k++)
                {
                    сочленения2[k].координаты = сочленения2[k].index.Координаты3D + ((Double3DPoint)(new Double3DPoint(сочленения2[k].index.направление) * -сочленения2[k].dist));
                    point1 = сочленения2[k].index.Координаты3D - сочленения2[k].Координаты3D;//part.задняя_тележка.координаты_3D;
                    point01 = point1.угол;
                    point2 = сочленения2[k].Координаты3D - сочленения2[k].target.Координаты3D;// - сочленения2[k].Координаты3D;
                    point02 = point2.угол;
                    сочленения2[k].направление.x = (point01.x + point02.x) / 2.0;
                    сочленения2[k].направление.y = (point01.y + point02.y) / 2.0;
                    if (Math.Abs(point01.x - point02.x) >= Math.PI)
                    {
                        сочленения2[k].направление.x += Math.PI;
                    }
                    if (Math.Abs(point01.y - point02.y) >= Math.PI)
                    {
                        сочленения2[k].направление.y += Math.PI;
                    }
//                    var point3 = new Double3DPoint(this.сочленения2[k].направление);
//                    point3.угол_y += 1.5707963267948966;
//                    сочленения2[k].координаты -= (Double3DPoint)(point3 * (axis_radius * 2));
                }/**/
            }


            public class ЧастьТрамвая : MeshObject, IОбъектПривязки3D, IVector, IMatrixObject
            {
                public ОбычныйТрамвай трамвай;
                public Double3DPoint _Координаты3D;
                public DoublePoint _direction;

                public virtual Matrix GetMatrix(int index)
                {
                    Matrix matrix = Matrix.RotationZ((float)НаправлениеY) * Matrix.RotationY(-((float)direction));
                    last_matrix = (matrix * Matrix.Translation((float)Координаты3D.x, (float)Координаты3D.y, (float)Координаты3D.z));
                    return last_matrix;//(matrix * Matrix.Translation((float)point.x, (float)point.y, (float)point.z));
                }

                public virtual int MatricesCount
                {
                    get
                    {
                        return 1;
                    }
                }

                public virtual DoublePoint position
                {
                    get
                    {
                        /*if (middle_index != -1)
                        {
                            DoublePoint point0;
                            DoublePoint point1;
                            if (middle_front)
                            {
                                point0 = трамвай.сочленения2[middle_index].position;
                                point1 = тележки[0].position;
                            }
                            else
                            {
                                point0 = тележки[0].position;
                                point1 = трамвай.сочленения2[middle_index].position;
                            }
                            return (DoublePoint)((point0 + point1) / 2.0);
                        }
                        return (DoublePoint)((тележки[0].position + тележки[1].position) / 2.0);*/
                        return Координаты3D.XZPoint;
                    }
                }

                public virtual Double3DPoint Координаты3D
                {
                    get
                    {
                        /*if (middle_index != -1)
                        {
                            Double3DPoint point0;
                            Double3DPoint point1;
                            if (middle_front)
                            {
                                point0 = трамвай.сочленения2[middle_index].Координаты3D;
                                point1 = тележки[0].координаты_3D;
                            }
                            else
                            {
                                point0 = тележки[0].координаты_3D;
                                point1 = трамвай.сочленения2[middle_index].Координаты3D;
                            }
                            return (Double3DPoint)((point1 + point0) / 2.0);
                        }
                        return (Double3DPoint)((тележки[1].координаты_3D + тележки[0].координаты_3D) / 2.0);*/
                        return _Координаты3D;
                    }
                }

                public virtual double direction
                {
                    get
                    {
                        /*DoublePoint point;
                        if (middle_index != -1)
                        {
                            DoublePoint point0;
                            DoublePoint point1;
                            if (middle_front)
                            {
                                point0 = трамвай.сочленения2[middle_index].position;
                                point1 = тележки[0].position;
                            }
                            else
                            {
                                point0 = тележки[0].position;
                                point1 = трамвай.сочленения2[middle_index].position;
                            }
                            point = point0 - point1;
                            return point.угол;
                        }
                        point = тележки[0].position - тележки[1].position;
                        return point.угол;*/
                        return _direction.x;
                    }
                }

                public DoublePoint направление_3D
                {
                    get
                    {
                        return new DoublePoint(direction, НаправлениеY);
                    }
                }

                public DoublePoint направление
                {
                    get
                    {
                        /*DoublePoint point3 = new DoublePoint(direction, НаправлениеY);
                        return point3;*/
                        return _direction;
                    }
                }

                public virtual double НаправлениеY
                {
                    get
                    {
                        /*Double3DPoint point;
                        DoublePoint point3;
                        if (middle_index != -1)
                        {
                            Double3DPoint point0;
                            Double3DPoint point1;
                            if (middle_front)
                            {
                                point0 = трамвай.сочленения2[middle_index].Координаты3D;
                                point1 = тележки[0].координаты_3D;
                            }
                            else
                            {
                                point0 = тележки[0].координаты_3D;
                                point1 = трамвай.сочленения2[middle_index].Координаты3D;
                            }
                            point = point0 - point1;
                            point3 = new DoublePoint(point.xz_point.модуль, point.y);
                            return point3.угол;
                        }
                        point = тележки[0].координаты_3D - тележки[1].координаты_3D;
                        point3 = new DoublePoint(point.xz_point.модуль, point.y);
                        return point3.угол;*/
                        return _direction.y;
                    }
                }
            }

            public class Дополнение : MeshObject, MeshObject.IFromFile, IMatrixObject
            {
                public string file;
                public Тип_дополнения тип;
                public ЧастьТрамвая частьТрамвая;

                public Дополнение(ЧастьТрамвая частьТрамвая, string filename, Тип_дополнения тип)
                {
                    this.частьТрамвая = частьТрамвая;
                    this.file = filename;
                    this.тип = тип;
                }

                public Matrix GetMatrix(int index)
                {
                    return частьТрамвая.last_matrix;//.GetMatrix(0);
                }

                public string Filename
                {
                    get
                    {
                        base.meshDir = this.частьТрамвая.meshDir;
                        return this.file;
                    }
                }

                public int MatricesCount
                {
                    get
                    {
                        return 1;
                    }
                }
            }

            public class Вагон : БазовыйВагон
            {
                public Вагон(Трамвай.ОбычныйТрамвай трамвай)//, Трамвай.Тележка передняя_тележка, Трамвай.Тележка задняя_тележка)
                {
                    base.трамвай = трамвай;
                    //                base.тележки[0] = передняя_тележка;
                    //                base.тележки[1] = задняя_тележка;
                }
                public override string Filename
                {
                    get
                    {
                        base.meshDir = трамвай.модель.dir;
                        return base.трамвай.модель.filename;
                    }
                }
            }

            public class Задний_Вагон : БазовыйВагон
            {
                public Задний_Вагон(Трамвай.ОбычныйТрамвай трамвай)//, Трамвай.Тележка передняя_тележка, Трамвай.Тележка задняя_тележка)
                {
                    base.трамвай = трамвай;
                    //                base.тележки[0] = передняя_тележка;
                    //                base.тележки[1] = задняя_тележка;
                }
                public override string Filename
                {
                    get
                    {
                        base.meshDir = трамвай.модель.dir;
                        int index = 0;
                        for (int i = 0; i < трамвай.хвосты.Length; i++)
                        {
                            if (this.трамвай.хвосты[i] == this)
                            {
                                index = i;
                                break;
                            }
                        }
                        return this.трамвай.модель.tails[index].filename;
                    }
                }
            }

            public abstract class БазовыйВагон : Трамвай.ОбычныйТрамвай.ЧастьТрамвая, MeshObject.IFromFile, IMatrixObject
            {
                protected БазовыйВагон()
                {
                }
                public abstract string Filename { get; }

                public void Обновить_маршрутный_указатель(string маршрут, string наряд)
                {
                    if (_meshTextureFilenames == null) return;
                    for (var i = 0; i < _meshTextureFilenames.Length; i++)
                    {
                        if (string.IsNullOrEmpty(_meshTextureFilenames[i])) continue;
                        var fullpath = _meshTextureFilenames[i];
                        var filename = "";
                        var ext = "";
                        var transport = "";

                        var startIndex = fullpath.LastIndexOf('.');
                        if (startIndex > 0)
                        {
                            ext = fullpath.Substring(startIndex);
                            fullpath = fullpath.Substring(0, startIndex);
                            startIndex = fullpath.LastIndexOf('\\');
                            filename = fullpath.Substring(startIndex);
                            fullpath = fullpath.Substring(0, startIndex);
                            startIndex = fullpath.LastIndexOf('\\');
                            transport = fullpath.Substring(startIndex);
                        }
                        var flag = true;
                        foreach (var str3 in extraMeshDirs)
                        {
                            if (File.Exists(str3 + transport + filename + маршрут + "-" + наряд + ext))
                            {
                                flag = false;
                                LoadTexture(i, transport + filename + маршрут + "-" + наряд + ext);
                                break;
                            }
                            if (!File.Exists(str3 + transport + filename + маршрут + ext)) continue;
                            flag = false;
                            LoadTexture(i, transport + filename + маршрут + ext);
                            break;
                        }
                        if (flag)
                        {
                            LoadTexture(i, _meshTextureFilenames[i]);
                        }
                    }
                }
            }

            /*public class Сочленение : ЧастьТрамвая, MeshObject.IFromFile //MeshObject, MeshObject.IFromFile, IMatrixObject, IVector, IОбъектПривязки3D
            {
                public bool _has;
                public Трамвай.Тележка тележка;
//                public Трамвай.Тележка задняя_тележка;
//                public Трамвай.Тележка передняя_тележка;
//                public ОбычныйТрамвай _трамвай;

                public Сочленение(ОбычныйТрамвай трамвай, Трамвай.Тележка передняя_тележка, Трамвай.Тележка задняя_тележка, Трамвай.Тележка тележка, bool есть)
                {
                    this.тележка = тележка;
                    this.тележки[1] = задняя_тележка;
                    this.тележки[0] = передняя_тележка;
                    this.трамвай = трамвай;
                    this._has = есть;
                }

                public override Matrix GetMatrix(int index)
                {
                    Matrix matrix = Matrix.RotationZ((float) this.НаправлениеY) * Matrix.RotationY(-((float) this.direction));
                    Double3DPoint point = this.Координаты3D;
                    last_matrix = (matrix * Matrix.Translation((float) point.x, (float) point.y, (float) point.z));
                    return last_matrix;
                }

                public string Filename
                {
                    get
                    {
                        /*if (_has)
                        {
                            base.meshDir = трамвай.модель.dir;
                            var index = 0;
                            for (var i = 0; i < трамвай.сочленения.Length; i++)
                            {
                                if (трамвай.сочленения[i] == this)
                                {
                                    index = i;
                                    break;
                                }
                            }                        
                            return трамвай.модель.tails[index].m_f;
                        }//
                        return null;
                    }
                }

                public override int MatricesCount
                {
                    get
                    {
                        return !this._has ? 0 : 1;
                    }
                }

                public override DoublePoint position
                {
                    get
                    {
                        return this.тележка.position;
                    }
                }

                public override Double3DPoint Координаты3D
                {
                    get
                    {
                        return this.тележка.координаты_3D;
                    }
                }

                public override double direction
                {
                    get
                    {
                        DoublePoint point = this.тележки[0].position - this.тележка.position;
                        double num = point.угол;
                        DoublePoint point2 = this.тележка.position - this.тележки[1].position;
                        double num2 = point2.угол;
                        if (Math.Abs((double) (num - num2)) < 3.1415926535897931)
                        {
                            return ((num + num2) / 2.0);
                        }
                        return (((num + num2) / 2.0) + 3.1415926535897931);                        
                    }
                }

                public override double НаправлениеY
                {
                    get
                    {
                        Double3DPoint point = this.тележки[0].координаты_3D - this.тележка.координаты_3D;
                        DoublePoint point2 = new DoublePoint(point.xz_point.модуль, point.y);
                        double num = point2.угол;
                        Double3DPoint point3 = this.тележка.координаты_3D - this.тележки[1].координаты_3D;
                        DoublePoint point4 = new DoublePoint(point3.xz_point.модуль, point3.y);
                        double num2 = point4.угол;
                        if (Math.Abs((double) (num - num2)) < 3.1415926535897931)
                        {
                            return ((num + num2) / 2.0);
                        }
                        return (((num + num2) / 2.0) + 3.1415926535897931);
                    }
                }
            }*/

            public class Сочленение_new : ЧастьТрамвая, MeshObject.IFromFile //MeshObject, MeshObject.IFromFile, IОбъектПривязки3D, IVector, IMatrixObject
            {
                /*public Double3DPoint _Координаты3D;
                public DoublePoint _direction;
                public ОбычныйТрамвай трамвай;*/
                //                public int index = 0;
                //                public int target = 1;
                public double dist = 0;//3.456;
                public int _index = 0;
                public int _target = 0;
                //                public ЧастьТрамвая index = null;
                //                public ЧастьТрамвая target = null;

                public Сочленение_new(/*int _index, */ОбычныйТрамвай трамвай, int ind, int tar, double distance)
                {
                    this.трамвай = трамвай;
                    //                    this.index = трамвай.Найти_часть(ind);
                    //                    this.target = трамвай.Найти_часть(tar);
                    _index = ind;
                    _target = tar;
                    this.dist = distance;
                    //                    this.target.middle_index = _index;
                    //                    this.target.middle_front = (ind < tar);
                    //                    this.target.УбратьТележку();
                }

                public override Matrix GetMatrix(int index)
                {
                    var matrix = Matrix.RotationZ((float)НаправлениеY) * Matrix.RotationY(-((float)this.direction));
                    last_matrix = (matrix * Matrix.Translation((float)_Координаты3D.x, (float)_Координаты3D.y, (float)_Координаты3D.z));
                    return last_matrix;
                }

                public string Filename
                {
                    get
                    {
                        base.meshDir = трамвай.модель.dir;
                        var index = 0;
                        for (var i = 0; i < трамвай.сочленения2.Length; i++)
                        {
                            if (трамвай.сочленения2[i] == this)
                            {
                                index = i;
                                break;
                            }
                        }
                        return трамвай.модель.сочленения[index].filename;
                        //                        return "сочленение2.x";
                    }
                }

                /*public int MatricesCount
                {
                    get
                    {
                        return 1;
                    }
                }

                /*public DoublePoint position
                {
                    get
                    {
                        return this._Координаты3D.xz_point;
                    }
                }

                /*public double direction
                {
                    get
                    {
                        return this._direction.x;
                    }
                }

                public Double3DPoint Координаты3D
                {
                    get
                    {
                        return this._Координаты3D;
                    }
                }

                public double НаправлениеY
                {
                    get
                    {
                        return _direction.y;
                    }
                }*/
            }

            public override Трамвай.Ось[] все_оси
            {
                get
                {
                    List<Ось> list = new List<Ось>();
                    foreach (var telega in this.тележки)
                    {
                        list.AddRange(new Трамвай.Ось[] { telega.оси[0], telega.оси[1] });
                    }
                    /*foreach (var telega in вагон.тележки)
                    {
                        list.AddRange(new Трамвай.Ось[] { telega.оси[0], telega.оси[1] });
                    }
                    foreach (var tail in this.хвосты)
                    {
                        foreach (var telega in tail.тележки)
                        {
                            list.AddRange(new Трамвай.Ось[] { telega.оси[0], telega.оси[1] });
                        }
                    }*/
                    return list.ToArray();
                }
            }

            public override Трамвай.Ось задняя_ось
            {
                get
                {
                    /*if (хвосты.Length > 0)
                    {
                        return хвосты[хвосты.Length - 1].тележки[хвосты[хвосты.Length - 1].тележки.Length - 1].оси[1];//.задняя_тележка.оси[1];
                    }
                    return вагон.тележки[1].оси[1];//.задняя_тележка.оси[1];*/
                    return тележки[тележки.Length - 1].оси[тележки[тележки.Length - 1].оси.Length - 1];
                }
            }

            public override Трамвай.Ось передняя_ось
            {
                get
                {
                    //                    return вагон.тележки[0].оси[0];//.передняя_тележка.оси[0];
                    return тележки[0].оси[0];
                }
            }

            public override DoublePoint position
            {
                get
                {
                    return вагон.position;
                }
            }

            public override Double3DPoint координаты_токоприёмника
            {
                get
                {
                    //                    var point = (вагон.middle_index == -1) ? вагон.тележки[1].position : сочленения2[вагон.middle_index].position;
                    //                    var point2 = вагон.тележки[0].position - point;
                    //                    return (point2 != Double3DPoint.Zero.xz_point) ? (point + ((DoublePoint)((point2 / point2.модуль) * модель.расстояние_между_тележками))) : point;//модель.расстояние_между_тележками)));
                    return вагон.Координаты3D + (new Double3DPoint(вагон.направление).Multyply(модель.пантограф.pos.x - модель.пантограф.dist));
                }
            }

            public override double direction
            {
                get
                {
                    return вагон.direction;
                }
            }

            public override Double3DPoint Координаты3D
            {
                get
                {
                    return this.вагон.Координаты3D;
                }
            }

            public override double НаправлениеY
            {
                get
                {
                    return this.вагон.НаправлениеY;
                }
            }

            public override Matrix преобразование_токоприёмника
            {
                get
                {
                    return (Matrix.Translation((float)модель.пантограф.pos.x, (float)модель.пантограф.pos.y, (float)модель.пантограф.pos.z) * вагон.GetMatrix(0));
                }
            }

            public int направление
            {
                get
                {
                    return base.система_управления.направление;
                }
            }
            public override double ускорение
            {
                get
                {
                    return base.система_управления.ускорение;
                }
            }
        }
        /// <summary>
        /// END_NEW
        /// </summary>


        /*        public class Маршрутный_Указатель : MeshObject, MeshObject.IFromFile, IMatrixObject
                {
                    public Matrix matrix;

                    public Matrix GetMatrix(int index)
                    {
                        return matrix;
                    }

                    public void Обновить(string маршрут)
                    {
                        if (_meshTextureFilenames != null)
                        {
                            for (int i = 0; i < _meshTextureFilenames.Length; i++)
                            {
                                if (_meshTextureFilenames[i] == "Маршрут.PNG")
                                {
                                    try
                                    {
                                        LoadTexture(i, "Маршрут" + маршрут + ".png");
                                    }
                                    catch
                                    {
                                        LoadTexture(i, "Маршрут.png");
                                    }
                                }
                            }
                        }
                    }

                    public string Filename
                    {
                        get
                        {
                            return "маршрут.x";
                        }
                    }

                    public int MatricesCount
                    {
                        get
                        {
                            return 1;
                        }
                    }
                }*/

        public class Ось : MeshObject, MeshObject.IFromFile, IMatrixObject, IVector
        {
            public bool в_обратную_сторону;
            public double пройденное_расстояние_общее;
            public double пройденное_расстояние_по_рельсу;
            public double радиус = 0.35;
            public Рельс текущий_рельс;
            public readonly ОбычныйТрамвай трамвай;

            public Ось(Рельс рельс, double расстояние_по_рельсу, double _радиус, ОбычныйТрамвай трамвай)
            {
                this.трамвай = трамвай;
                радиус = _радиус;
                текущий_рельс = рельс;
                пройденное_расстояние_по_рельсу = расстояние_по_рельсу;
                //                текущий_рельс.objects.Add(this);
            }

            public void cменить_текущий_рельс(Рельс рельс)
            {
                if (текущий_рельс != null)
                {
                    текущий_рельс.objects.Remove(this);
                }
                текущий_рельс = рельс;
                текущий_рельс.objects.Add(this);
            }

            ~Ось()
            {
                if (текущий_рельс != null)
                {
                    текущий_рельс.objects.Remove(this);
                }
            }

            public Matrix GetMatrix(int index)
            {
                Matrix matrix = Matrix.RotationZ(-((float)(пройденное_расстояние_общее / радиус))) * Matrix.RotationY(-((float)direction));
                Double3DPoint point = координаты_3D;
                return (matrix * Matrix.Translation((float)point.x, (float)point.y, (float)point.z));
            }

            public void Передвинуть(double расстояние)
            {
                double dist = пройденное_расстояние_по_рельсу;
                int reverse_dir = в_обратную_сторону ? -1 : 1;
                пройденное_расстояние_по_рельсу += reverse_dir * расстояние;
                if (текущий_рельс.высота[0] != текущий_рельс.высота[1])
                {
                    if (расстояние != 0.0)
                    {
                        double num3 = текущий_рельс.НайтиВысоту(пройденное_расстояние_по_рельсу) - текущий_рельс.НайтиВысоту(dist);
                        double num4 = (расстояние * расстояние) / ((расстояние * расстояние) + (num3 * num3));
                        расстояние = (пройденное_расстояние_по_рельсу - dist) * num4;
                        пройденное_расстояние_по_рельсу = dist + расстояние;
                        расстояние *= reverse_dir;
                    }
                    //                    double d = текущий_рельс.НайтиНаправлениеY(пройденное_расстояние_по_рельсу) + 1.5707963267948966;
                    трамвай.скорость -= Math.Sin(текущий_рельс.НайтиНаправлениеY(пройденное_расстояние_по_рельсу)) * Road.uklon_koef * World.прошлоВремени;//* 0.03;
                                                                                                                                                           //                    трамвай.скорость += Math.Cos(текущий_рельс.НайтиНаправлениеY(пройденное_расстояние_по_рельсу) + MyFeatures.halfPI) * 0.03;
                }
                пройденное_расстояние_общее += расстояние;
                Проверить_контакты(dist, пройденное_расстояние_по_рельсу);
                while ((пройденное_расстояние_по_рельсу < 0.0) && (текущий_рельс.предыдущие_рельсы.Length > 0))
                {
                    cменить_текущий_рельс(текущий_рельс.предыдущие_рельсы[текущий_рельс.предыдущий_рельс]);
                    пройденное_расстояние_по_рельсу += текущий_рельс.Длина;
                    Проверить_контакты(текущий_рельс.Длина + 1.0, пройденное_расстояние_по_рельсу);
                }
                while ((пройденное_расстояние_по_рельсу > текущий_рельс.Длина) && (текущий_рельс.следующие_рельсы.Length > 0))
                {
                    пройденное_расстояние_по_рельсу -= текущий_рельс.Длина;
                    cменить_текущий_рельс(текущий_рельс.следующие_рельсы[текущий_рельс.следующий_рельс]);
                    Проверить_контакты(-1.0, пройденное_расстояние_по_рельсу);
                }
            }

            private void Проверить_контакты(double расстояние_old, double расстояние_new)
            {
                if (!(передняя)) return;
                foreach (object obj2 in текущий_рельс.objects)
                {
                    if (!(obj2 is Сигнальная_система.Контакт)) continue;
                    var контакт = (Сигнальная_система.Контакт)obj2;
                    if ((контакт.расстояние < расстояние_new) && (контакт.расстояние >= расстояние_old))
                    {
                        if (!контакт.минус)
                        {
                            контакт.система.состояние++;
                        }
                        else
                        {
                            контакт.система.состояние--;
                        }
                    }
                    if ((контакт.расстояние >= расстояние_old) || (контакт.расстояние < расстояние_new)) continue;
                    if (контакт.минус)
                    {
                        контакт.система.состояние++;
                        continue;
                    }
                    контакт.система.состояние--;
                }
            }

            public string Filename
            {
                get
                {
                    //                    return "ось.x";
                    base.meshDir = трамвай.модель.dir;
                    return this.трамвай.модель.axisfilename;
                }
            }

            public int MatricesCount
            {
                get
                {
                    return 1;
                }
            }

            public DoublePoint position
            {
                get
                {
                    return текущий_рельс.НайтиКоординаты(пройденное_расстояние_по_рельсу, 0.0);
                }
            }

            public Double3DPoint координаты_3D
            {
                get
                {
                    var point = new Double3DPoint();
                    point.XZPoint = position;
                    point.y = текущий_рельс.НайтиВысоту(пройденное_расстояние_по_рельсу) + 0.05;
                    double d = текущий_рельс.НайтиНаправлениеY(пройденное_расстояние_по_рельсу) + (Math.PI / 2.0);
                    //                    point.xz_point += (DoublePoint)((new DoublePoint(direction) * радиус) * Math.Cos(d));
                    point.XZPoint = point.XZPoint.Add(new DoublePoint(direction).Multyply(радиус * Math.Cos(d)));
                    point.y += радиус * Math.Sin(d);
                    return point;
                }
            }

            public double direction
            {
                get
                {
                    return текущий_рельс.НайтиНаправление(пройденное_расстояние_по_рельсу);
                }
            }

            public bool передняя
            {
                get
                {
                    return ((трамвай != null) && (this == трамвай.передняя_ось));
                }
            }

            public bool задняя
            {
                get
                {
                    return ((трамвай != null) && (this == трамвай.задняя_ось));
                }
            }
        }

        public class Тележка : MeshObject, MeshObject.IFromFile, IMatrixObject, IVector
        {
            public Ось[] оси;
            public readonly ОбычныйТрамвай трамвай;
            public double default_dist;

            public Тележка(Рельс рельс, double расстояниеПоРельсу, double dist, double axis_radius, ОбычныйТрамвай трамвай)
            {
                оси = new[] { new Ось(рельс, расстояниеПоРельсу - dist, axis_radius, трамвай), new Ось(рельс, расстояниеПоРельсу - dist - трамвай.расстояние_между_осями, axis_radius, трамвай) };
                this.трамвай = трамвай;
                this.default_dist = dist;
            }

            public Matrix GetMatrix(int index)
            {
                var matrix = Matrix.RotationZ((float)направление_y) * Matrix.RotationY(-((float)direction));
                var point = координаты_3D;
                return (matrix * Matrix.Translation((float)point.x, (float)point.y, (float)point.z));
            }

            public string Filename
            {
                get
                {
                    base.meshDir = трамвай.модель.dir;
                    return this.трамвай.модель.telegafilename;
                    //                    return "тележка.x";
                }
            }

            public int MatricesCount
            {
                get
                {
                    return 1;
                }
            }

            public DoublePoint position
            {
                get
                {
                    return (оси[0].position + оси[1].position) / 2.0;
                }
            }

            public Double3DPoint координаты_3D
            {
                get
                {
                    return (оси[0].координаты_3D + оси[1].координаты_3D) / 2.0;
                }
            }

            public double direction
            {
                get
                {
                    DoublePoint point = оси[1].position - оси[0].position;
                    return point.Angle;
                }
            }

            public double направление_y
            {
                get
                {
                    Double3DPoint point = оси[1].координаты_3D - оси[0].координаты_3D;
                    DoublePoint point3 = new DoublePoint(point.XZPoint.Modulus, point.y);
                    return point3.Angle;
                }
            }
        }

        public abstract class Токоприёмник_new : ITest2
        {
            private Трамвайный_контактный_провод _fпровод;
            public double высота = 0.0;
            public double высота_max = 5.0;
            public double высота_min = 4.0;
            //            public double высота_дуги = 0.2;
            public double высота_основания = 3.35;
            //            public double lenght = 0.2;
            public double width = 0.53;
            protected double dist = 0.0;

            public Double3DPoint position;
            public Часть[] части;
            public bool поднимается = true;
            public Трамвай трамвай;

            public abstract Matrix GetMatrix(int index);
            public abstract void Обновить(World мир);

            public virtual void Render()
            {
                foreach (var часть in части)
                {
                    часть.Render();
                }
            }

            public virtual void CreateMesh()
            {
                foreach (var часть in части)
                {
                    часть.CreateMesh();
                }
            }

            public void CheckCondition()
            {
                foreach (var часть in части)
                {
                    часть.IsNear = true;
                }
            }

            public void НайтиПровод(Контактный_провод[] контактныеПровода)
            {
                double minHeight = 1000.0;
                double curHeight = -1000.0;

                var position2D = position.XZPoint;
                foreach (var провод in контактныеПровода)
                {
                    if (провод.обесточенный)
                        continue;

                    var pantRelativePos = position2D - провод.начало;
                    pantRelativePos.Angle -= провод.направление;
                    if ((Math.Abs(pantRelativePos.y) <= width) && ((pantRelativePos.x >= 0.0) && (pantRelativePos.x <= провод.длина)))
                    {
                        var projectedPantPos = new DoublePoint(провод.направление).Multyply(pantRelativePos.x).Add(ref провод.начало);
                        var normal = DoublePoint.Distance(ref projectedPantPos, ref position2D);
                        curHeight = провод.FindHeight(pantRelativePos.x);
                        if ((normal <= width) && (curHeight < minHeight))
                        {
                            Провод = (Трамвайный_контактный_провод)провод;
                            minHeight = curHeight;
                            continue;
                        }
                    }
                }
            }

            public double обычная_высота_max
            {
                get
                {
                    if (Провод != null)
                    {
                        return ((Провод.FindHeight(ПройденноеРасстояниеПоПроводу) + Контактный_провод.высота_контактной_сети) - position.y - 0.03);
                    }
                    return высота_min;
                }
            }

            public bool опущен
            {
                get
                {
                    return (высота <= высота_min);
                }
            }

            public bool поднят
            {
                get
                {
                    return ((Провод != null) && (высота >= обычная_высота_max));
                }
            }

            public Трамвайный_контактный_провод Провод
            {
                get
                {
                    return _fпровод;
                }
                set
                {
                    if (_fпровод != null)
                    {
                        _fпровод.objects.Remove(this);
                    }
                    _fпровод = value;
                    if (value != null)
                    {
                        value.objects.Add(this);
                    }
                }
            }

            public double ПройденноеРасстояниеПоПроводу
            {
                get
                {
                    if (Провод != null)
                    {
                        //                        var point = position.XZPoint - Провод.начало;
                        //                        return point.Modulus;
                        var positionXZ = position.XZPoint;
                        return DoublePoint.Distance(ref positionXZ, ref Провод.начало);
                    }
                    return 0.0;
                }
            }

            public class Часть : MeshObject, MeshObject.IFromFile, IMatrixObject
            {
                private readonly Токоприёмник_new токоприёмник;
                private int _index;
                private string filename;
                public double height;
                public double width;
                public double length;
                public double norm_ang;

                public Часть(Токоприёмник_new токоприёмник, string filename, int ind, double _height, double _width, double _length, double ang)
                {
                    this.токоприёмник = токоприёмник;
                    this._index = ind;
                    this.filename = filename;
                    this.height = _height;
                    this.width = _width;
                    this.length = _length;
                    this.norm_ang = ang;
                }

                public Matrix GetMatrix(int index)
                {
                    return токоприёмник.GetMatrix(_index);
                }

                public string Filename
                {
                    get
                    {
                        base.meshDir = токоприёмник.трамвай.модель.пантограф.dir;
                        return this.filename;//токоприёмник.трамвай.модель.пантограф.part_filename;
                    }
                }

                public int MatricesCount
                {
                    get
                    {
                        return 1;
                    }
                }
            }

            public class Пантограф : Токоприёмник_new
            {
                //                private const double num4 = 1.5;

                public Пантограф(Трамвай tramway, double base_height, double min_height, double max_height)
                {
                    base.трамвай = tramway;
                    base.высота_основания = base_height;
                    base.высота_min = min_height;
                    base.высота_max = max_height;
                    base.dist = трамвай.модель.пантограф.dist;
                    base.части = new Часть[трамвай.модель.пантограф.parts.Length];
                    for (int i = 0; i < base.части.Length; i++)
                    {
                        base.части[i] = new Часть(this, трамвай.модель.пантограф.parts[i].filename, i, трамвай.модель.пантограф.parts[i].height, трамвай.модель.пантограф.parts[i].width, трамвай.модель.пантограф.parts[i].length, трамвай.модель.пантограф.parts[i].ang);//трамвай.модель.пантограф.parts[i].index
                    }
                }

                public override void Обновить(World мир)
                {
                    position = трамвай.координаты_токоприёмника;//Trash.PointFromMatrix(трамвай.преобразование_токоприёмника);//tr.вагон.Координаты3D + ((Double3DPoint)(new Double3DPoint(tr.вагон.направление) * tr.модель.пантограф.pos.x));
                    if (Провод != null)
                    {
                        var dist = ПройденноеРасстояниеПоПроводу;
                        if ((dist > Провод.длина) && (Провод.следующие_провода2.Length > 0))
                        {
                            Провод = Провод.следующие_провода2[0];
                        }
                        else if ((dist < 0.0) && (Провод.предыдущие_провода2.Length > 0))
                        {
                            Провод = Провод.предыдущие_провода2[0];
                        }
                        else
                        {
                            dist = Math.Max(0, Math.Min(dist, Провод.длина));
                            var point = Провод.FindCoords(dist, 0.0);
                            var point2 = position.XZPoint - point;
                            if (point2.Modulus > width)
                            {
                                Провод = null;
                                НайтиПровод(мир.контактныеПровода2);
                            }
                        }
                    }
                    else
                    {
                        поднимается = false;
                    }
                    if (поднимается && !поднят)
                    {
                        высота += 0.8 * World.прошлоВремени;
                    }
                    else if (!поднимается && !опущен)
                    {
                        высота -= 0.8 * World.прошлоВремени;
                    }
                    if (высота > высота_max)
                    {
                        высота = высота_max;
                        поднимается = false;
                        return;
                    }
                    if (опущен)
                    {
                        высота = высота_min;
                    }
                    if (поднят)
                    {
                        высота = обычная_высота_max;//высота_max;
                    }
                }

                public override Matrix GetMatrix(int index)
                {
                    var matrix = трамвай.преобразование_токоприёмника;
                    var _height = высота - высота_основания;
                    if (index == 0)
                    {
                        return matrix;
                    }
                    if (index == (части.Length - 1))
                    {
                        return (Matrix.Translation(-(float)dist, (float)_height, 0f) * matrix);
                    }
                    //c^2=a^2+b^2-2*a*b*cosA!!!
                    //2*a*b*cosA=a^2+b^2-c^2
                    //cosA=(a^2+b^2-c^2)/2*a*b
                    //--------------как это можно было забыть???
                    //2/some_sin=_height/add_sin
                    //2*add_sin=_height*some_sin
                    //some_sin=2*add_sin/_height
                    double add_cos = 0.0;
                    double length1 = index > 2 ? части[3].length : части[1].length;
                    double length2 = index > 2 ? части[4].length : части[2].length;
                    _height -= части[части.Length - 1].height;
                    if (dist != 0.0)
                    {
                        add_cos = Math.Sqrt(1 / (1 + Math.Pow(_height / dist, 2.0)));
                        _height = dist / add_cos;
                    }
                    double target_cos = (Math.Pow(length1, 2.0) + Math.Pow(length2, 2.0) - Math.Pow(_height, 2.0)) / (2.0 * length1 * length2);
                    double add_sin = Math.Sqrt(1 - Math.Pow(target_cos, 2.0));
                    add_sin = length2 * add_sin / _height;
                    double rot1 = (Math.PI / 2.0) - Math.Asin(add_sin);
                    if (length2 * target_cos > length1)
                    {
                        rot1 = -rot1;//Math.Asin(add_sin) - Math.PI / 2.0;
                    }
                    if (dist != 0.0)
                    {
                        rot1 += (Math.PI / 2.0) - Math.Acos(add_cos);
                    }
                    switch (index)
                    {
                        case 1:
                            {
                                rot1 += части[1].norm_ang;
                                return (Matrix.RotationZ((float)rot1) * matrix);
                            }

                        case 2:
                            {
                                return (Matrix.RotationZ(-(float)(Math.Acos(target_cos) - части[2].norm_ang)) * Matrix.Translation((float)части[1].length, 0.0f, 0.0f) * Matrix.RotationZ((float)rot1) * matrix);
                            }

                        case 3:
                            {
                                rot1 -= части[3].norm_ang;
                                return (Matrix.RotationZ(-(float)rot1) * Matrix.Translation((float)(dist * -2.0), 0f, 0f) * matrix);
                            }

                        case 4:
                            {
                                return (Matrix.RotationZ((float)(Math.Acos(target_cos) + части[4].norm_ang)) * Matrix.Translation(-(float)части[3].length, 0.0f, 0.0f) * Matrix.RotationZ(-(float)rot1) * Matrix.Translation((float)(dist * -2.0), 0f, 0f) * matrix);
                            }
                    }
                    /*var num = высота - высота_дуги;
                    var num2 = высота_основания + ((num - высота_основания) / 2.0);
                    var y = num - num2;
                    if (y < 0.0)
                    {
                        y = 0.0;
                    }
                    else if (y > num4)
                    {
                        y = num4;
                    }
                    var x = Math.Sqrt((num4 * num4) - (y * y));
                    var point = new Double3DPoint(x, y, 0.0);
                    var point1 = new Double3DPoint(0.0, 2.0 * y, 0.0);
                    switch (index)
                    {
//                        case 0:
//                            return matrix;

                        case 1:
                            return (GetMatrix(Double3DPoint.Zero, point) * matrix);

                        case 2:
                            return (GetMatrix(point, point1) * matrix);

//                        case 3:
//                            return (Matrix.Translation(0f, (float)(высота - высота_основания), 0f) * matrix);
                    }*/
                    return Matrix.Identity;
                }
            }
        }//
    }
}